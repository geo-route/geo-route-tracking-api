using System.Text.Json;
using GeoRoute.Platform.Tracking.Api.Exceptions;
using GeoRoute.Platform.Tracking.Data.Dto;
using JetBrains.Annotations;

namespace GeoRoute.Platform.Tracking.Api.Middleware;

public class ErrorResponseMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorResponseMiddleware> _logger;

    public ErrorResponseMiddleware(RequestDelegate next, ILogger<ErrorResponseMiddleware> logger)
    {
        this._next = next;
        this._logger = logger;
    }

    [UsedImplicitly]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "AV1755:Name of async method should end with Async or TaskAsync", Justification = "Interface method.")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Miscellaneous Design", "AV1210:Catch a specific exception instead of Exception, SystemException or ApplicationException", Justification = "Logging and error handling")]
    public async Task Invoke(HttpContext ctx)
    {
	    try {
		    ctx.Request.EnableBuffering();
		    await this._next(ctx).ConfigureAwait(false);
	    } catch(InvalidInputException exception) {
		    var response = await RespondErrorAsync(ctx, exception.Message, (int) exception.StatusCode);
		    this._logger.LogWarning("Unable to process a request due to invalid input (id: {id:D})", response.Id);
	    } catch(HttpException exception) {
		    var response = await RespondErrorAsync(ctx, exception.Message, (int) exception.StatusCode);
		    this._logger.LogWarning("Unable to process a request due to a user error (id: {id:D})", response.Id);
	    } catch(Exception ex) {
            var response = await RespondErrorAsync(ctx, "Unable to complete request.", 500).ConfigureAwait(false);
            this._logger.LogError(ex, "Uncaught exception. Generated by request: {id:D}", response.Id);
        }
    }

    private static async Task<HttpResult<string>> RespondErrorAsync(HttpContext ctx, string err, int statusCode)
    {
        var id = (Guid)ctx.Items["RequestId"]!;
        var response = new HttpResult<string> { Errors = new List<string>(), Id = id };

        response.Errors.Add(err);
        ctx.Response.Headers["Content-Type"] = "application/json";
        ctx.Response.StatusCode = statusCode;

        await ctx.Response.WriteAsync(JsonSerializer.Serialize(response)).ConfigureAwait(false);
        return response;
    }
}
